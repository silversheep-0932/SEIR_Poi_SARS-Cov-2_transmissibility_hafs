<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>SEIR ê°ì—¼í™•ë¥  ê³„ì‚°ê¸°</title>
  <style>
    body{font-family:system-ui,Arial;margin:18px auto;max-width:980px;padding:12px}
    .card{border:1px solid #e6e6e6;border-radius:8px;padding:12px;margin:12px 0}
    label{display:block;margin:8px 0 4px}
    input,select,button{font-size:14px;padding:8px;width:100%;box-sizing:border-box}
    .row{display:flex;gap:12px}
    .col{flex:1}
    pre{background:#fafafa;padding:10px;border-radius:6px;overflow:auto}
    small{color:#666}
  </style>
</head>
<body>
  <h1>SEIR ê¸°ë°˜ SARS-CoV-2 ê°ì—¼í™•ë¥  ê³„ì‚°ê¸°</h1>
  <div style="font-size:12px; color:#777; margin-top:-10px; margin-bottom:14px;">
  â€» ì™¸ëŒ€ë¶€ê³  í•™ìƒë“¤ì´ ì‹¤í—˜ì ìœ¼ë¡œ ë§Œë“  í”„ë¡œê·¸ë¨ìœ¼ë¡œ, ì‹¤ì œ ì •í™•ë„ëŠ” ë–¨ì–´ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
  </div>


  <div class="card">
    <h3>1) íŒŒì¼ ì—…ë¡œë“œ</h3>
    <small>ì‹ ê·œ í™•ì§„ì(ì¼ë³„) CSV, ì¸êµ¬ìˆ˜(ì›”ë³„) CSV</small>
    <label>ì‹ ê·œ í™•ì§„ì CSV (ì¼ë³„) â€” í—¤ë” ì˜ˆ: ì¼ì,ì„œìš¸,ë¶€ì‚°,... (ë‚ ì§œ: YYYY-MM-DD)</label>
    <input id="casesFile" type="file" accept=".csv" />
    <label>ì¸êµ¬ìˆ˜ CSV (ì›”ë³„) â€” í—¤ë” ì˜ˆ: ì¼ì,ì„œìš¸,ë¶€ì‚°,... (ì¼ì: YYYY-MM)</label>
    <input id="popFile" type="file" accept=".csv" />
    <div id="fileStatus" style="margin-top:8px;color:green"></div>
  </div>

  <div class="card">
    <h3>2) ì…ë ¥ (ë‹¬ë ¥ ë²”ìœ„: 2020-01-01 ~ 2023-12-31)</h3>
    <div class="row">
      <div class="col">
        <label>í˜„ì¬ ë‚ ì§œ (2020. 01. 20. ~ 2023. 08. 31.)</label>
        <input id="currentDate" type="date" min="2020-01-01" max="2023-12-31" />
                
        <label style="margin-top:10px">ì§€ì—­(ì‹œë„)</label>
        <select id="region"><option value="">(íŒŒì¼ ì—…ë¡œë“œ í›„ ì„ íƒ)</option></select>

        <label style="margin-top:10px">ì˜¨ë„ (Â°C)</label>
        <input id="tempInput" type="number" step="0.1" value="20">

        <label>ìƒëŒ€ìŠµë„ (% RH) (20-80%)</label>
        <input id="humInput" type="number" step="0.1" value="50">

      </div>
      <div class="col">
        <label>ì‹¤ë‚´ ë©´ì  (ã¡)</label>
        <input id="area" type="number" value="50" />
        <label>í™œì„±ë„ (ì˜ˆ: 5-20, í´ìˆ˜ë¡ ì‚¬ëŒë“¤ì´ í™œë°œí•˜ê²Œ ì›€ì§ì„)</label>
        <input id="activity" type="number" step="0.1" value="1.0" />
        <label>ì˜ˆìƒ ì²´ë¥˜ ì‹œê°„ (h)</label>
        <input id="duration" type="number" step="0.1" value="2" />

            </div>
        </div>
  </div>

  <div class="card">
    <h3>3) ì‹¤í–‰</h3>
    <button id="runBtn">ê³„ì‚° ì‹œì‘</button>
    <div id="status" style="margin-top:8px;color:#b33"></div>
  </div>

  <div class="card">
    <h3>ê²°ê³¼</h3>
    <div id="output"></div>
  </div>

  <div class="card">
    <h3>ë””ë²„ê·¸ (ì˜¤ë¥˜ê°€ ë‚˜ë©´ ì´ ë‚´ìš©ì„ ê·¸ëŒ€ë¡œ ë¶™ì—¬ì¤˜)</h3>
    <pre id="debug"></pre>
  </div>

<script>
// ---------------------------
// ë‚´ë¶€ ìƒìˆ˜ (UIì— ë…¸ì¶œë˜ì§€ ì•ŠìŒ)
// ---------------------------
const beta_SEIR = 0.48; // 1/day, SEIR ì „ìš©
const latent_days = 2; // ì ë³µê¸°ê°„(ì¼)

// ---------------------------
// CSV íŒŒì„œ (ë”°ì˜´í‘œ ë‚´ë¶€ ì½¤ë§ˆ ì²˜ë¦¬, ì²œë‹¨ìœ„ ì‰¼í‘œ ì œê±°)
// ---------------------------
function splitCSVLine(line){
  const res=[]; let cur=''; let inQ=false;
  for(let i=0;i<line.length;i++){
    const ch=line[i];
    if(ch === '"'){ inQ = !inQ; continue; }
    if(ch === ',' && !inQ){ res.push(cur); cur=''; continue; }
    cur += ch;
  }
  res.push(cur);
  return res.map(s=>s.trim().replace(/^"|"$/g,''));
}
function parseCSVText(text){
  const lines = text.replace(/\r\n/g,'\n').replace(/\r/g,'\n').split('\n').map(l=>l);
  while(lines.length && lines[0].trim()==='') lines.shift();
  while(lines.length && lines[lines.length-1].trim()==='') lines.pop();
  if(lines.length===0) return {header:[], rows:[]};
  const header = splitCSVLine(lines[0]);
  const rows = [];
  for(let i=1;i<lines.length;i++){
    const cols = splitCSVLine(lines[i]);
    const obj = {};
    for(let j=0;j<header.length;j++){
      let v = cols[j]===undefined ? '' : cols[j];
      v = String(v).replace(/,/g,'').trim();
      obj[header[j]] = v;
    }
    rows.push(obj);
  }
  return {header, rows};
}

// ---------------------------
// ì „ì—­ ìƒíƒœ
// ---------------------------
let casesHeader=null, casesRows=null, casesIndex={};      // casesIndex[YYYY-MM-DD] -> {region: num}
let popHeader=null, popRows=null, populationByYM={};     // populationByYM['YYYY-MM'] -> {region: pop}
let regions = [];

// ---------------------------
// íŒŒì¼ ì—…ë¡œë“œ ì²˜ë¦¬
// ---------------------------
const fileStatus = document.getElementById('fileStatus');

document.getElementById('casesFile').addEventListener('change', async (e)=>{
  try{
    const txt = await e.target.files[0].text();
    const parsed = parseCSVText(txt);
    casesHeader = parsed.header; casesRows = parsed.rows;
    buildCasesIndex();
    fileStatus.innerHTML = (fileStatus.innerHTML?fileStatus.innerHTML+'<br>':'') + 'ğŸ“Œ í™•ì§„ì CSV ì—…ë¡œë“œ ì™„ë£Œ';
  } catch(err){ fileStatus.innerHTML = 'í™•ì§„ì CSV ì½ê¸° ì‹¤íŒ¨: ' + err.message; }
});

document.getElementById('popFile').addEventListener('change', async (e)=>{
  try{
    const txt = await e.target.files[0].text();
    const parsed = parseCSVText(txt);
    popHeader = parsed.header; popRows = parsed.rows;
    buildPopulationIndex();
    fileStatus.innerHTML = (fileStatus.innerHTML?fileStatus.innerHTML+'<br>':'') + 'ğŸ“Œ ì¸êµ¬ìˆ˜ CSV ì—…ë¡œë“œ ì™„ë£Œ';
  } catch(err){ fileStatus.innerHTML = 'ì¸êµ¬ CSV ì½ê¸° ì‹¤íŒ¨: ' + err.message; }
});

// ---------------------------
// ì¸ë±ìŠ¤ ë¹Œë“œ
// ---------------------------
function normalizeToYYYYMMDD(raw){
  if(!raw) return null;
  raw = String(raw).trim();
  // ì´ë¯¸ YYYY-MM-DD í˜•ì‹ì´ë©´ ê·¸ëŒ€ë¡œ ë°˜í™˜
  if(/^\d{4}-\d{2}-\d{2}$/.test(raw)) return raw;
  // YYYY.MM.DD or YYYY/MM/DD or YYYY MM DD -> ë°”ê¿”ì„œ ì²˜ë¦¬
  const dotMatch = raw.match(/^(\d{4})[.\-\/\s](\d{1,2})[.\-\/\s](\d{1,2})$/);
  if(dotMatch){
    const y = dotMatch[1];
    const mo = String(dotMatch[2]).padStart(2,'0');
    const da = String(dotMatch[3]).padStart(2,'0');
    return `${y}-${mo}-${da}`;
  }
  // YYYY-MM (ì›” ë‹¨ìœ„) -> YYYY-MM-01
  if(/^\d{4}-\d{2}$/.test(raw)) return raw + '-01';
  // YYYY.MM (ì˜ˆ: "2020.01") -> YYYY-MM-01
  const moOnly = raw.match(/^(\d{4})[.\-\/\s](\d{1,2})$/);
  if(moOnly){
    return `${moOnly[1]}-${String(moOnly[2]).padStart(2,'0')}-01`;
  }
  // ì¼ë°˜ì ìœ¼ë¡œ Dateê°€ íŒŒì‹± ê°€ëŠ¥í•˜ë©´ ì‚¬ìš© (ë¸Œë¼ìš°ì €ì— ì˜ì¡´)
  const d = new Date(raw);
  if(!isNaN(d)){
    return d.toISOString().slice(0,10);
  }
  // ë§ˆì§€ë§‰ìœ¼ë¡œ, ìˆ«ìë“¤(ë…„,ì›”,ì¼)ì„ ìœ ì—°í•˜ê²Œ ì¡ì•„ë³´ê¸° (ì˜ˆ: "20200102")
  const compact = raw.match(/^(\d{4})(\d{2})(\d{2})$/);
  if(compact){
    return `${compact[1]}-${compact[2]}-${compact[3]}`;
  }
  return null;
}
function normalizeToYYYYMM(raw){ const d=normalizeToYYYYMMDD(raw); return d ? d.slice(0,7) : null; }

function buildCasesIndex(){
  casesIndex = {};
  if(!casesHeader || !casesRows) return;
  const candidates = ['ì¼ì','Date','date','ë‚ ì§œ','day'];
  const dateCol = casesHeader.find(h=>candidates.includes(h)) || casesHeader[0];
  regions = casesHeader.filter(h=>h !== dateCol);
  for(const row of casesRows){
    const raw = row[dateCol];
    const norm = normalizeToYYYYMMDD(raw);
    if(!norm) continue;
    const rec = {};
    for(const r of regions){
      let v = row[r];
      if(v === '' || v === undefined || v === '-') v = '0';
      const n = Number(String(v).replace(/,/g,'')); rec[r] = isNaN(n) ? 0 : n;
    }
    casesIndex[norm] = rec;
  }
  populateRegionSelect(regions);
  }

function buildPopulationIndex(){
  populationByYM = {};
  if(!popHeader || !popRows) return;
  const dateCandidates = ['ì¼ì','Date','date','ë‚ ì§œ','month'];
  const dateCol = popHeader.find(h=>dateCandidates.includes(h)) || popHeader[0];
  const regCols = popHeader.filter(h=>h !== dateCol);
  for(const row of popRows){
    const raw = row[dateCol];
    const ym = normalizeToYYYYMM(raw);
    if(!ym) continue;
    populationByYM[ym] = populationByYM[ym] || {};
    for(const r of regCols){
      let v = row[r];
      if(v === '' || v === undefined) { populationByYM[ym][r] = null; continue; }
      const n = Number(String(v).replace(/,/g,'')); populationByYM[ym][r] = isNaN(n) ? null : n;
    }
  }
  if(regions.length === 0 && Object.keys(populationByYM).length > 0){
    const firstYM = Object.keys(populationByYM)[0];
    populateRegionSelect(Object.keys(populationByYM[firstYM]));
  }
}

// ---------------------------
// UI helper
// ---------------------------
function populateRegionSelect(regs){
  const sel = document.getElementById('region');
  sel.innerHTML = '';
  regs.forEach(r => { const o = document.createElement('option'); o.value=r; o.textContent=r; sel.appendChild(o); });
}

// ---------------------------
// SEIR ì‹œë®¬ë ˆì´í„°
// ---------------------------
function seir_daily(I,E,S,R, beta_day, sigma, gamma, days){
  let S0=S, E0=E, I0=I, R0=R;
  for(let d=0; d<days; d++){
    const newExp = beta_day * S0 * I0;
    const dS = - newExp;
    const dE = newExp - sigma * E0;
    const dI = sigma * E0 - gamma * I0;
    const dR = gamma * I0;
    S0 += dS; E0 += dE; I0 += dI; R0 += dR;
    S0=Math.max(0,S0); E0=Math.max(0,E0); I0=Math.max(0,I0); R0=Math.max(0,R0);
  }
  return {S:S0,E:E0,I:I0,R:R0};
}
// í•˜ë£¨(step) ë‹¨ìœ„ì˜ SEIR ì—…ë°ì´íŠ¸(ë¹„ìœ¨ ë‹¨ìœ„)
// ì…ë ¥/ì¶œë ¥ì€ fraction(0..1)
function seir_step(S, E, I, beta_day, sigma, gamma){
  const newExp = beta_day * S * I;
  const dS = - newExp;
  const dE = newExp - sigma * E;
  const dI = sigma * E - gamma * I;
  const S2 = S + dS;
  const E2 = E + dE;
  const I2 = I + dI;
  return { S: Math.max(0, S2), E: Math.max(0, E2), I: Math.max(0, I2) };
}

function calcBetaFromTH(T, H){
    return -0.0001712316*(H**2)+0.0108354543*H+0.49881235810

}
// --- SEIR ê¸°ë°˜ìœ¼ë¡œ 'í˜„ì¬ ë‚ ì§œê¹Œì§€' ëª¨ë¸ì„ ë§ì¶”ê³ 
//     ë‚´ì¼ë¶€í„° latent_days(ì˜ˆ:2)ì¼ê¹Œì§€ì˜ ì‹ ê·œ I(=í™•ì§„) í•©ì„ ë°˜í™˜
// --- currentDateStr (YYYY-MM-DD), region, population ì‚¬ìš©
function estimateLatentsUsingSEIR(currentDateStr, region, population){
  const dbgEl = document.getElementById('debug');

  const dates = Object.keys(casesIndex).sort((a,b)=>new Date(a)-new Date(b));
  if(dates.length === 0){
    dbgEl.textContent += 'estimateLatentsUsingSEIR: casesIndexì— ë‚ ì§œê°€ ì—†ìŠµë‹ˆë‹¤.\n';
    return 0;
  }

  const sigma = 1/latent_days; // E -> I ì „í™˜ìœ¨ (1/day)
  const gamma = 1/7; // íšŒë³µë¥  (1/day)

  // ìƒíƒœëŠ” fraction (sum S+E+I+R <= 1)
  let S = 1.0, E = 0.0, I = 0.0, R = 0.0;
  let lastSimDate = null;

  dbgEl.textContent += `--- casesIndex ìƒ˜í”Œ(ìµœëŒ€ 10ê°œ) ---\n`;
  for(let i=0;i<Math.min(10, dates.length); i++){
    const d = dates[i];
    const v = (casesIndex[d] && casesIndex[d][region]) ? casesIndex[d][region] : 0;
    dbgEl.textContent += `${d}: ${v}\n`;
  }
  dbgEl.textContent += `ì´ ë‚ ì§œ ìˆ˜: ${dates.length}\n`;

  // (ì˜µì…˜) ë³´ê³ ìœ¨: ì‹¤ì œ ë°œìƒ ëŒ€ë¹„ ë³´ê³ ëœ í™•ì§„ ë¹„ìœ¨ (0~1). UIë¡œ ë…¸ì¶œ ê¶Œì¥.
  const reporting = 1.0; // ê¸°ë³¸ 1.0 (ì™„ì „ë³´ê³ ). í˜„ì‹¤ì ìœ¼ë¡  0.2~0.6 ë“±ìœ¼ë¡œ ì„¤ì • ê°€ëŠ¥.

  // ----------------------------
  // 1) FITTING: "í˜„ì¬ ë‚ ì§œ - 14ì¼" ~ "í˜„ì¬ ë‚ ì§œ ì§ì „" ê¹Œì§€ë§Œ ì‚¬ìš©
  // ----------------------------
  const currentDate = new Date(currentDateStr);
  const fitStartDate = new Date(currentDate);
  fitStartDate.setDate(fitStartDate.getDate() - 14);

  for(const d of dates){
    const dd = new Date(d);

    // 14ì¼ ì´ì „ì´ë©´ ìŠ¤í‚µ
    if(dd < fitStartDate) continue;

    // í˜„ì¬ ë‚ ì§œëŠ” ì‚¬ìš© X
    if(dd >= currentDate) break;

    const realCases = (casesIndex[d] && casesIndex[d][region]) ? casesIndex[d][region] : 0;
    const observed_frac = realCases / population; // í•˜ë£¨ ê´€ì¸¡ incidence (fraction)

    // ê´€ì¸¡ì¹˜ ì—­íˆ¬ì˜: observed â‰ˆ reporting * sigma * E  => required_E = observed / (sigma * reporting)
    if(observed_frac > 0){
      const required_E = observed_frac / (sigma * reporting);

      if(required_E > E){
        const deltaE = required_E - E;
        // ì§ˆëŸ‰ ë³´ì¡´: Sì—ì„œ êº¼ë‚´ì„œ Eë¡œ ì¶”ê°€
        S -= deltaE;
        if(S < 0){
          // Sê°€ ë¶€ì¡±í•˜ë©´ ê°€ëŠ¥í•œ ë§Œí¼ë§Œ ì±„ì›€
          const actualDelta = deltaE + S; // S is negative
          E += actualDelta > 0 ? actualDelta : 0;
          S = Math.max(0, S);
        } else {
          E += deltaE;
        }
      }
      // ë§Œì•½ required_E <= Eì¸ ê²½ìš°ì—ëŠ” 'Eë¥¼ ì¤„ì´ì§€ ì•ŠìŒ' (ëª¨ë¸ì´ ì´ë¯¸ ê³¼ëŒ€í‰ê°€ì¤‘ì´ë¼ë©´ ìì—°ê°ì†Œë¥¼ í—ˆìš©)
    }

    // í•˜ë£¨ ì „ì§„ (ì¼ ë‹¨ìœ„)
    const step = seir_step(S, E, I, beta_SEIR, sigma, gamma);
    S = step.S; E = step.E; I = step.I;
    R = Math.max(0, 1 - S - E - I);

    lastSimDate = d;
  }

  dbgEl.textContent += `ëª¨ë¸ í”¼íŒ… ì¢…ë£Œì¼(í¬í•¨ë˜ì§€ ì•ŠìŒ): ${lastSimDate}\n`;
  dbgEl.textContent += `í”¼íŒ… í›„ ìƒíƒœ(S,E,I,R) ë¹„ìœ¨: ${S.toExponential(6)}, ${E.toExponential(6)}, ${I.toExponential(6)}, ${R.toExponential(6)}\n`;

  // ----------------------------
  // 2) PREDICT: "ë‚´ì¼"ê³¼ "ëª¨ë ˆ" (ì¦‰ latent_days ì¼ìˆ˜ë§Œí¼ ì•ìœ¼ë¡œ) ì˜ ì‹ ê·œ í•©ì„ ê³„ì‚°
  //    - ê° ì¼ì˜ ì‹ ê·œ(ëª…) = sigma * E_fraction * population
  // ----------------------------
  let fS = S, fE = E, fI = I, fR = R;
  let sumNew = 0;
  dbgEl.textContent += `ì˜ˆì¸¡ ì‹œì‘ ìƒíƒœ(S,E,I): ${fS.toExponential(6)}, ${fE.toExponential(6)}, ${fI.toExponential(6)}\n`;
  for(let k=0; k<latent_days; k++){
    // í•˜ë£¨ ì‹ ê·œ(ë¹„ìœ¨) = sigma * E
    const daily_new_frac = sigma * fE;
    const daily_new_num = daily_new_frac * population;
    sumNew += daily_new_num;

    dbgEl.textContent += `ì˜ˆì¸¡ì¼ ${k+1}: daily_new_frac=${daily_new_frac.toExponential(6)} (ëª…=${daily_new_num.toFixed(6)})\n`;

    // í•˜ë£¨ ì „ì§„
    const st = seir_step(fS, fE, fI, beta_SEIR, sigma, gamma);
    fS = st.S; fE = st.E; fI = st.I;
    fR = Math.max(0, 1 - fS - fE - fI);
  }

  dbgEl.textContent += `ì˜ˆì¸¡ í•©ê³„(sumNew, ë‚´ì¼+ëª¨ë ˆ ì‹ ê·œ í•©): ${sumNew.toFixed(6)} ëª…\n`;
  dbgEl.textContent += `------------------------------------------\n`;
  return sumNew;
}

// ---------------------------
// ì‹¤í–‰: í˜„ì¬ ì´ì „ ë°ì´í„°ë§Œ ì‚¬ìš©í•´ì„œ I0/E0 ì¶”ì • -> targetê¹Œì§€ ì‹œë®¬ë ˆì´ì…˜ -> í™˜ê²½ í™•ë¥  ê³„ì‚°
// ---------------------------
document.getElementById('runBtn').addEventListener('click', ()=>{
  const T_env = Number(document.getElementById('tempInput').value);
  const H_env = Number(document.getElementById('humInput').value);
  const beta_env = calcBetaFromTH(T_env, H_env);

  const out = document.getElementById('output');
  const dbg = document.getElementById('debug');
  out.innerHTML = ''; dbg.textContent = '';

  if(!casesRows || !popRows){ out.innerText = 'ë‘ CSV íŒŒì¼ì„ ëª¨ë‘ ì—…ë¡œë“œí•˜ì„¸ìš”.'; return; }

  // target ìš°ì„ : ìº˜ë¦°ë” ê°’ ìš°ì„ , ì•„ë‹ˆë©´ select
  const target = document.getElementById('currentDate').value;
  const current = document.getElementById('currentDate').value;
  const region = document.getElementById('region').value;
  const A = Number(document.getElementById('area').value);
  const a = Number(document.getElementById('activity').value);
  const T = Number(document.getElementById('duration').value);
  const extraElem = document.getElementById('extraHours');
  const extraH = extraElem ? (Number(extraElem.value) || 0) : 0;

  
  if(!current || !target){ out.innerText = 'í˜„ì¬ ë‚ ì§œì™€ ì˜ˆì¸¡ ë‚ ì§œë¥¼ ëª¨ë‘ ì…ë ¥/ì„ íƒí•˜ì„¸ìš”.'; return; }
  if(!region){ out.innerText = 'ì§€ì—­ì„ ì„ íƒí•˜ì„¸ìš”.'; return; }

  const currentDate = new Date(current);
  const targetDate = new Date(target);

  // population (month)
  const ym = target.slice(0,7);
  const popMap = populationByYM[ym];
  if(!popMap){ out.innerHTML = `í•´ë‹¹ ì›”(${ym})ì˜ ì¸êµ¬ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.`; return; }
  const population = popMap[region];
  if(!population || population <= 0){ out.innerText = 'ì¸êµ¬ ë°ì´í„°ê°€ ë¹„ì •ìƒì…ë‹ˆë‹¤.'; return; }

  // --- SEIR ê¸°ë°˜ ì ë³µì ê³„ì‚° (ìš”ì²­í•œ ë°©ì‹)
  // (1) casesIndexì— ë‚ ì§œê°€ ì „í˜€ ì—†ìœ¼ë©´ ì¢…ë£Œ
  const allDates = Object.keys(casesIndex).sort((a,b)=>new Date(a)-new Date(b));
  if(allDates.length === 0){ out.innerText = 'í˜„ì¬ ë‚ ì§œ ì´ì „ì˜ í™•ì§„ì ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.'; return; }

  // (2) estimateLatentsUsingSEIRë¥¼ í˜¸ì¶œí•˜ì—¬ 'í˜„ì¬ ë‚ ì§œì˜ ì ë³µì ìˆ˜'ë¥¼ ì–»ìŒ
  const latentCount = estimateLatentsUsingSEIR(current, region, population); // ëª…
  const E_fraction = latentCount / population; // fractionìœ¼ë¡œ ë³€í™˜

  // debug ì¶œë ¥ (ì„ íƒ)
  dbg.textContent += `SEIR ê¸°ë°˜ ì¶”ì • ì ë³µì ìˆ˜(ëª…): ${latentCount.toFixed(6)}\n`;
  dbg.textContent += `ì ë³µì ë¹„ìœ¨: ${(E_fraction*100).toFixed(8)}%\n`;
  dbg.textContent += `ì¸êµ¬(ì›”): ${population.toLocaleString()}\n`;
  dbg.textContent += `latentCount (ëª…): ${latentCount.toFixed(2)}\n`;
  dbg.textContent += `E_fraction (ë¹„ìœ¨): ${(E_fraction*100).toFixed(6)}%\n`;
  dbg.textContent += `í™˜ê²½ ë² íƒ€(beta_env): ${beta_env.toExponential ? beta_env.toExponential(4) : beta_env}\n`;

  // ì¶”ê°€ ë””ë²„ê·¸: ì „ì²´ ë‚ ì§œ ìˆ˜ ë° í”¼íŒ… ì‹œì‘ì¼(í˜„ì¬ runBtn ìŠ¤ì½”í”„ì—ì„œ ê³„ì‚°)
  dbg.textContent += `ì´ ë‚ ì§œ ìˆ˜: ${allDates.length}\n`;
  const currentDateObj = new Date(current);
  const fitStartDateObj = new Date(currentDateObj);
  fitStartDateObj.setDate(fitStartDateObj.getDate() - 14);
  dbg.textContent += `SEIR í”¼íŒ… ì‹œì‘ì¼: ${fitStartDateObj.toISOString().slice(0,10)}\n`;


  // environment risk calculation
  const r = 1; const areaCircle = Math.PI * r * r;
  const n_risk = E_fraction * (areaCircle / A); // expected latent in radius r
  const n_eff = a * n_risk;
  const lambda_per_hour = beta_env * n_eff; // environment beta applied here
  const p_no = Math.exp(- lambda_per_hour * T);
  const P = 1 - p_no;

  out.innerHTML =
    `<b>ìš”ì•½</b><br>` +
    `ì˜ˆì¸¡ì¼: ${target} (ì›”: ${ym})<br>` +
    `ì§€ì—­: ${region} / ì¸êµ¬(ì›”): ${population.toLocaleString()}<br>` +
    `í•´ë‹¹ì¼(ë˜ëŠ” ì‹œì ) ì ë³µêµ° ë¹„ìœ¨ E: ${(E_fraction*100).toFixed(6)}%<br>` +
    `<b>Î» (per hour):</b> ${lambda_per_hour.toExponential(4)}<br>` +
    `<b>ìµœì¢… ê°ì—¼í™•ë¥ :</b> ${(P*100).toFixed(6)}%`;

}); // end run

</script>
</body>
</html>
